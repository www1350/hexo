---
title: 函数式编程
abbrlink: 1690d21b
date: 2022-03-09 23:06:59
tags:
categories:
typora-root-url: ../../source
---

## 编程范式

Programming paradigm(编程范式) 是指某种编程语言典型的编程风格或编程方式。 编程范式是编程语言的一种分类方式，它并不针对某种编程语言。就编程语言而言，一种编程语言也可以适用多种编程范式。

常见的编程范型有：[函数式编程](https://zh.wikipedia.org/wiki/函數式編程)、[指令式编程](https://zh.wikipedia.org/wiki/指令式编程)、[过程式编程](https://zh.wikipedia.org/wiki/过程式编程)、[面向对象编程](https://zh.wikipedia.org/wiki/面向对象编程)等等。

### 指令式编程

**指令式编程、命令式编程**（英语：Imperative programming）；是一种描述电脑所需作出的行为的[编程典范](https://zh.wikipedia.org/wiki/編程典範)。几乎所有电脑的[硬件](https://zh.wikipedia.org/wiki/硬體)都是指令式工作；几乎所有电脑的硬件都是能执行[机器代码](https://zh.wikipedia.org/wiki/機器碼)，而机器代码是使用指令式的风格来写的。较高端的指令式[编程语言](https://zh.wikipedia.org/wiki/編程語言)使用[变量](https://zh.wikipedia.org/wiki/變數)和更复杂的语句，但仍依从相同的典范。菜谱和行动清单，虽非计算机程序，但与指令式编程有相似的风格：每步都是指令。因为指令式编程的基础观念，不但概念上比较熟悉，而且较容易具体表现于硬件，所以大部分的编程语言都是指令式的。

#### 原理和基础

很多指令式编程语言（比如[Fortran](https://zh.wikipedia.org/wiki/Fortran)、[BASIC](https://zh.wikipedia.org/wiki/BASIC)和[C](https://zh.wikipedia.org/wiki/C语言)）是[汇编语言](https://zh.wikipedia.org/wiki/汇编语言)的[抽象化](https://zh.wikipedia.org/wiki/抽象化_(計算機科學))。

大部分的[高级语言](https://zh.wikipedia.org/wiki/高级语言)都支持四种基本的语句：

1. **运算语句**一般来说都表现了在存储器内的资料进行运算的行为，然后将结果存入存储器中以便日后使用。高端指令式编程语言更能处理复杂的表达式，可能会产生四则运算和函数计算的结合。
2. **循环语句**容许一些语句反复执行数次。循环可依据一个默认的数目来决定执行这些语句的次数；或反复执行它们，直至某些条件改变。
3. **条件分支语句**容许仅当某些条件成立时才执行某个区块。否则，这个区块中的语句会略去，然后按区块后的语句继续执行。
4. **无条件分支语句**容许执行顺序转移到程序的其他部分之中。包括跳跃（在很多语言中称为[Goto](https://zh.wikipedia.org/wiki/Goto)）、副程序和Procedure等。

循环、条件分支和无条件分支都是[控制流程](https://zh.wikipedia.org/wiki/控制流程)。

一些语言，如：Fortran, [Java](https://www.geeksforgeeks.org/java/), [C](https://www.geeksforgeeks.org/c-programming-language/), [C++](https://www.geeksforgeeks.org/c-plus-plus/) 

### 声明式编程

**声明式编程**（英语：Declarative programming）或译为声明式编程，是对与[命令式编程](https://zh.wikipedia.org/wiki/指令式編程)不同的[编程范型](https://zh.wikipedia.org/wiki/编程范型)的一种合称。它们建造计算机程序的结构和元素，表达[计算](https://zh.wikipedia.org/wiki/计算)的逻辑而不用描述它的[控制流程](https://zh.wikipedia.org/wiki/控制流程)。开发人员更关心的答案。它声明那种我们想要的结果,编程语言只关注如何产生



### 区别

- 命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。
- 声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。

![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/157470078-42270eb9-131b-46f4-a7a6-7b8d38d177a7-20220309233741541.png)



![image.png](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646646643161-8f4178d6-cb26-4802-a3e6-059d5f87ad6a.png)



现在下面这样的表达式

```r
(1+2) * 8 / 4
```



命令式

```cpp
int a = 1 + 2;
int b = a * 8;
int c = b / 4;
```

声明式

```r
divide(multiply(add(1, 2), 3), 4)
```



### 过程式编程

**过程式程序设计**（英语：Procedural programming），又称过程化编程，一种[编程典范](https://zh.wikipedia.org/wiki/編程典範)，派生自[指令式编程](https://zh.wikipedia.org/wiki/指令式編程)，有时会被视为是同义语。主要要采取[过程调用](https://zh.wikipedia.org/wiki/子程序)或函数调用的方式来进行[流程控制](https://zh.wikipedia.org/wiki/流程控制)。流程则由包涵一系列运算步骤的过程（Procedures），例程（routines），[子程序](https://zh.wikipedia.org/wiki/子程序)（subroutines）, 方法（methods），或函数（functions）来控制。在程序执行的任何一个时间点，都可以调用某个特定的程序。任何一个特定的程序，也能被任意一个程序或是它自己本身调用。

过程化语言适合解决线性的算法问题，强调“自上而下”、“精益求精”的设计方式。



最初的主要过程式编程语言出现在大约1957年至1964年，包括[Fortran](https://zh.wikipedia.org/wiki/Fortran)、[ALGOL](https://zh.wikipedia.org/wiki/ALGOL)、[COBOL](https://zh.wikipedia.org/wiki/COBOL)、[PL/I](https://zh.wikipedia.org/wiki/PL/I)和[BASIC](https://zh.wikipedia.org/wiki/BASIC)，后来的[Pascal](https://zh.wikipedia.org/wiki/Pascal_(程式語言))和[C](https://zh.wikipedia.org/wiki/C语言)发表于大约1970年至1972年。





### 面向对象编程

**面向对象程序设计**（英语：Object-oriented programming，[缩写](https://zh.wikipedia.org/wiki/缩写)：OOP）是种具有[对象](https://zh.wikipedia.org/wiki/对象_(计算机科学))概念的[编程典范](https://zh.wikipedia.org/wiki/编程范型)，同时也是一种程序开发的抽象方针。它可能包含[数据](https://zh.wikipedia.org/wiki/数据)、[特性](https://zh.wikipedia.org/wiki/特性_(计算机科学))、[代码](https://zh.wikipedia.org/wiki/源代码)与[方法](https://zh.wikipedia.org/wiki/方法_(電腦科學))。对象则指的是[类](https://zh.wikipedia.org/wiki/类_(计算机科学))（class）的实例。它将[对象](https://zh.wikipedia.org/wiki/物件_(電腦科學))作为[程序](https://zh.wikipedia.org/wiki/计算机程序)的基本单元，将程序和[数据](https://zh.wikipedia.org/wiki/数据)[封装](https://zh.wikipedia.org/wiki/封裝_(物件導向程式設計))其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。

重要的面向对象编程语言包含[Common Lisp](https://zh.wikipedia.org/wiki/Common_Lisp)、[Python](https://zh.wikipedia.org/wiki/Python)、[C++](https://zh.wikipedia.org/wiki/C%2B%2B)、[Objective-C](https://zh.wikipedia.org/wiki/Objective-C)、[Smalltalk](https://zh.wikipedia.org/wiki/Smalltalk)、[Delphi](https://zh.wikipedia.org/wiki/Delphi)、[Java](https://zh.wikipedia.org/wiki/Java)、[Swift](https://zh.wikipedia.org/wiki/Swift_(程式語言))、[C#](https://zh.wikipedia.org/wiki/C♯)、[Perl](https://zh.wikipedia.org/wiki/Perl)、[Ruby](https://zh.wikipedia.org/wiki/Ruby)、[JavaScript](https://zh.wikipedia.org/wiki/JavaScript) 与 [PHP](https://zh.wikipedia.org/wiki/PHP)等。

![image-20220309233528183](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/image-20220309233528183-6840323.png)





### 并行编程模式

在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**并行编程模型**（Parallel programming model）是[并行计算机](https://zh.wikipedia.org/wiki/并行计算)架构的[抽象化](https://zh.wikipedia.org/wiki/抽象化_(計算機科學))，通过它可方便的表达[算法](https://zh.wikipedia.org/wiki/算法)和它们在[程序](https://zh.wikipedia.org/wiki/计算机程序)中的合成。判别编程模型的价值可以通过它的通用性：在各种不同架构上能表达多大范围的不同问题，和它的性能：编译的程序在执行时有多高的效率[[1\]](https://zh.wikipedia.org/wiki/并行编程模型#cite_note-Skillicorn-1)。并行编程模型的实现形式可以是从“顺序编程”语言中调用的[函数库](https://zh.wikipedia.org/wiki/函式庫)，作为现存语言的扩展，或作为全新的语言。

围绕特定编程模型的共识是很重要的，这可导致建造不同的并行计算机来支持这个模型，从而促进软件的[可移植性](https://zh.wikipedia.org/wiki/軟體可移植性)。在这个意义上，编程模型被称为在硬件和软件之间的[桥接](https://zh.wikipedia.org/w/index.php?title=桥接模型&action=edit&redlink=1)[[2\]](https://zh.wikipedia.org/wiki/并行编程模型#cite_note-Valiant1990-2)。



![img](/hexo/images/1646723393125-4ee8e029-5dcd-4f9f-b8b5-f12af590eab8.png)

关键：

- 任务分解，识别出多个能够并发执行的任务
- 数据分解，识别出从属于每个任务的局部数据
- 分组任务和排序分组的方式满足时间约束
- 任务之间的依赖分析



![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646723405108-44c8f62d-6eca-465d-86ce-9945b18b3f0a.png)

关键：

- 任务并行，重点要解决任务之间的依赖性，解决顺序依赖约束和共享数据依赖约束，可以通过消除依赖、分离依赖等方式解决；通过轮询、工作窃取法等方式来实现调度
- 



![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646723420340-41d09cf6-6f16-42fc-920d-3c7d218c9c91-6840367.png)



关键：

- SPMD（单程序多数据）。在SPMD程序中，所有UE（执行单元）并行执行同一个程序（单程序），但每个UE都拥有自己的私有数据集（多数据）
- 主从模式。主进程为从进程建立一个工作池和一个任务包。所有从进程并发执行，每个从进程迭代的从任务包中移除一个任务并处理它，指导所有任务都处理完毕或到达某些终止条件为止
- 循环并行。该模式解决计算密集型循环为主导串行程序转成并行程序时出现的问题
- 派生聚合模式Fork/Join 模式。一个主UE里面Fork出多个子的UE，这些子UE并行完成任务的一部分，等待这一步的全部子UE完成了这些任务之后，进行聚合操作。
- 共享数据。解决多个UE共享数据时常见问题，并讨论正确性和性能。[共享内存](https://zh.wikipedia.org/wiki/共享内存)是在进程间传递数据的高效方式。在共享内存模型中，并行进程共享它们可以异步读与写的全局地址空间。异步并发访问可能导致[竞争条件](https://zh.wikipedia.org/wiki/竞争条件)，和用来避免它们的机制如：[锁](https://zh.wikipedia.org/wiki/锁_(计算机科学))、[信号量](https://zh.wikipedia.org/wiki/信号量)和[监视器](https://zh.wikipedia.org/wiki/监视器_(程序同步化))。常规的[多核处理器](https://zh.wikipedia.org/wiki/多核处理器)直接支持共享内存
- 分布式数组模式。一维或多维数组，被划分为多个子数组，并在进程或线程间进行分配



![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646723444427-c4d5040f-4fb8-40e8-9029-d8326dd23d62-6840376.png)



关键：

- UE管理。线程/进程的创建和销毁
- 同步。内存同步和围栅、栏栅、互斥
- 通信。消息传递、集合通信

![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646646751422-c6d6dd51-5936-43d7-b357-90e299f9f76e-6840384.png)





### 逻辑编程

逻辑编程是种编程典范，它设定答案须符合的规则来解决问题，而非设定步骤来解决问题，过程是事实+规则=结果。

事实

实际上，每个逻辑程序都需要使用事实才能实现给定的目标。事实基本上是关于程序和数据的真实陈述。例如，新德里是印度的首都。

规则

实际上，规则是允许我们对问题域做出结论的约束。规则基本上写成逻辑条款来表达各种事实。例如，如果我们正在构建任何游戏，那么必须定义所有规则。

规则对于解决逻辑编程中的任何问题非常重要。规则基本上是逻辑结论，可以表达事实。以下是规则的语法

```r
A∶− B1,B2,...,Bn.
```

这里，A是头部，B1，B2，... Bn是身体。

例如 − ancestor(X,Y) :- father(X,Y).

ancestor(X,Z) :- father(X,Y), ancestor(Y,Z).

这可以理解为，对于每个X和Y，如果X是Y的父亲而Y是Z的祖先，则X是Z的祖先。对于每个X和Y，X是Z的祖先，如果X是Y和Y的父亲是Z的祖先。



python-kanren




![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646727263171-2b1c6cb6-7791-4703-843d-e21ee7509e08.png)

### 数据驱动编程

在计算机编程中，**数据驱动**编程，是一种[编程范式](https://zh.wikipedia.org/wiki/编程范式)，在其中程序语句描述要匹配的数据，和对它需要做的处理，程序本身不定义选取数据的一序列文件操作步骤[[1\]](https://zh.wikipedia.org/wiki/数据驱动编程#cite_note-awk-1)。数据驱动语言的标准例子是文本处理语言[sed](https://zh.wikipedia.org/wiki/Sed)和[AWK](https://zh.wikipedia.org/wiki/AWK)[[1\]](https://zh.wikipedia.org/wiki/数据驱动编程#cite_note-awk-1)，在其中数据是[输入流](https://zh.wikipedia.org/wiki/標準串流)中的一序列的行，因而它们也叫面向行的语言，而[模式匹配](https://zh.wikipedia.org/wiki/模式匹配)主要通过[正则表达式](https://zh.wikipedia.org/wiki/正则表达式)或行号来完成。

在数据驱动的编程中,由数据本身驱动程序的逻辑。在游戏编程中,通常是数据驱动的编程方式使用某种形式的脚本语言。游戏的行为由变化的数据文件决定,而不做任何重新编译。



无数据驱动的时候

```xml
data_lloyd = {'name': 'Lloyd', 'lives': 'Alcoy }
data_jason = {'name': 'Jason', 'lives': 'London' }
go = function(x) 
    if x.name == 'Lloyd' 
    then 
        print("Alcoy, Spain") 
    else 
        print("London, UK") 
end
```



数据驱动

```xml
data_lloyd = {'name': 'Lloyd', 'lives': function(){ print("Alcoy, Spain") }
data_jason = {'name': 'Jason', 'lives': function(){ print("London, UK") }
go = function(x)
    x.lives()
end
```





demo：

我们将使用一个简单的门。当玩家进入一个触发器区域,门打开时,当玩家离开引发地区,门关闭:

![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646731476987-ba1b4d64-4ef2-4e4d-91c4-1b04fcabf94a.png)

如果我们让触发器区域覆盖整个门,然后门更多的是一种视觉细节,像一个星际旅行输送机的门:

![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646731517811-695d1abd-95bc-4dc0-94cb-caee362d0549.png)

我们可以创建一个触发门对象有两个部分:一个触发器区域(即不是画在屏幕上),和一个物理的门,这是绘制在屏幕上,和通过阻止玩家/怪物。我们的门可以有两种状态,打开和关闭。关闭时,碰撞区域的门充满整个部分的走廊,当打开碰撞区域移动(或门对象标记为一个对象,不会撞上东西。)



```python
class WorldObject
   {
       public Vector2 Position { get; set; }
       public Rectangle CollisionArea { get; set; }
       public bool CallbackIfNotColliding { get; set; }
    
       // Called when the world detects a collision, with a pointer
       //  to the object we collided with
       public virtual void Collide(WorldObject otherObject) { }
    
       // Called when we don't collide with anything, if our
       // CallbackIfNotColliding flag is set
       public virtual void NoCollision() { }
   }
   class Door : WorldObject
   {
       public void Draw(Spritebatch sb)
       {
            if (mIsOpen)
            {
            	// Draw open door
            }
            else
            {
            	// Draw closed door
            }
       
       		// Could also keep track if door is opening / closing, draw animation
       }
       
       public void Update(GameTime gameTime)
       {
            // Updating for any dynamic behavior (like animating opening / closing,
            //    or a revolving door, or something else)       
       }
       
       
        public bool IsOpen
        {
            get
            {
                return mIsOpen;
            }
            set
            {
            	if (value != mIsOpen)
                {
                  // Either modify collision volume that world uses, or set a flag
                  //  for the world to ignore / allow collisions with this door 
                  mIsOpen = value;
                }
            }
       }
       		
       private bool mIsOpen;
   }
```







```python
class TriggeredDoor : WorldObject
{
     private Door mDoor;

     public override void Collide(WorldObject otherObject)
     {
     	Door.IsOpen = true;
     }
     
     public override void NoCollide()
     {
     	Door.IsOpen = false;
     }
}
```





```xml
<TriggeredDoor>
  <TriggerArea type = "Rectangle">
    <x>
      300
    </x>
    <y> 
      200
    </y>
    <w>
      30
    </w>
    <h>
      20
    </h>
  </TriggerArea>
  <ClosedCollisionArea type = "Rectangle">
    <x>
      320
    </x>
    <y> 
      200
    </y>
    <w>
      5
    </w>
    <h>
      20
    </h>
  </ClosedCollisionArea>
  <OpenCollisionArea type = "Rectangle">
    <x>
      320
    </x>
    <y> 
      200
    </y>
    <w>
      5
    </w>
    <h>
      2
    </h>
  </OpenCollisionArea>
  <OpenTexture type = "String">OpenDoor1</OpenTexture>
  <ClosedTexture type = "String">ClosedDoor1</ClosedTexture>
  <TexturePosition type = "Vector2">
    <x>
      100
    </x>
    <y> 
      100
      
      </TexturePosition>
</TriggeredDoor>
```

当你输入一个特定的体积。如果有一个全局函数,关掉灯,我们可以在我们的世界文件中创建一个条目,看起来像下面的:



```xml
  <TriggeringArea>
     <Area type = "Rectangle">
        <x>
           100
        </x>
        <y>
           50
        </y> 
        <w>
           30
        </w> 
        <h>
            10
        </h>
     </Area>
     <code>
         TurnOffLights()
     </code>
  </triggeringarea>
```

脚本执行器

```xml
  Object obj = Scripting.GetInstance();                              // Get a pointer ot the object
  MethodType method = obj.GetType().GetMethod("TurnOnLights");       // Get a pointer to the method object
  Obj [] params = new Obj[0];                                        // Array of parameters (none, in this example)
  method.Invoke(obj, params);                                        // Call the method
  
```







在其之下隐藏的设计思想

1、控制复杂度。通过把程序逻辑的复杂度转移到人类更容易处理的数据中来，从而达到控制复杂度的目标。代码流程从命令式变成了 声明式
2、隔离变化。像上面的例子，每个消息处理的逻辑是不变的，但是消息可能是变化的，那就把容易变化的消息和不容易变化的逻辑分离。
3、机制和策略的分离。机制就是消息的处理逻辑，策略就是不同的消息处理。

![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646654817397-cc4ea5b6-a55e-4d97-a923-7f3810607fbb.png)



### 函数式编程

**函数式编程**，或称**函数程序设计**、**泛函编程**（英語：Functional programming），是一种[编程范式](https://zh.wikipedia.org/wiki/编程范式)，它将[电脑运算](https://zh.wikipedia.org/wiki/電腦運算)视为[函数](https://zh.wikipedia.org/wiki/函数)运算，并且避免使用程式[状态](https://zh.wikipedia.org/w/index.php?title=状态_(计算机科学)&action=edit&redlink=1)（英语：[State (computer science)](https://en.wikipedia.org/wiki/State_(computer_science))）以及[易变物件](https://zh.wikipedia.org/wiki/不可變物件)。其中，[λ演算](https://zh.wikipedia.org/wiki/Λ演算)为该语言最重要的基础。而且，λ演算的函数可以接受函数作为输入參數和输出返回值。

比起[指令式編程](https://zh.wikipedia.org/wiki/指令式編程)，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。

在函数式编程中，函数是[头等对象](https://zh.wikipedia.org/wiki/头等对象)，意思是说一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。



早在50年代函数式编程开始之前，Lisp 语言就已经在 IBM 700/7000 系列的科学计算机上运行了。Lisp 引入了很多与我们现在的函数式编程有关的示例与功能，我们甚至可以称 Lisp 是所有函数式编程语言的鼻祖。

这也是函数式编程中最有趣的方面，所有函数式编程语言都是基于相同的 [λ演算](https://zh.wikipedia.org/wiki/Λ演算)，这种简单数学基础。



λ演算是图灵完备的，它是一种通用的计算模型，可用于模拟任何一台单带图灵机。它名字中的希腊字母 lambda（λ），被使用在了 lambda 表达式和 lambda 项绑定函数中的变量中。

λ演算是一个极其简单但又十分强大的概念。它的核心主要有两个概念：

- 函数的抽象，通过引入变量来归纳得出表达式；
- 函数的应用，通过给变量赋值来对已得出的表达式进行计算；

让我们来看个小例子，单参数函数 f，将参数递增1。

```xml
f = λ x. x+1 
```

假设我们应用函数在数字5上，那么函数读取如下：

```xml
f(5) => 5 + 1
```



#### 函数式编程的基本原理

现在，数学知识已经够了。让我们看一下使函数式编程变得强大的特性有哪些？

##### 头等函数（first-class function）

在函数式编程中，函数是一等公民，意思是说函数可以赋值给变量，例如在 [elixir](http://elixir-lang.org/getting-started/introduction.html) 中，

```xml
double = fn(x) -> x * 2 
```

然后我们可以如下来调用函数：

```xml
double.(2) 
```

scala

```xml
def m(x: Int):Int = x * 2

m(2) //输出4
```



scala匿名函数/闭包

```xml
val m = (x: Int) => x * 2
```





java中的运用



```xml
    @FunctionalInterface
    interface FunctionMul{
        int multiTwo(int x);
    }        

    
    FunctionMul func = x -> x * 2;
    func.multi(2); //输出4
```

一个最常用的Function

![img](/hexo/images/1646740610546-c1403a0d-4ca7-498b-8b57-eb4c33e699b4.png)

```xml
Function<Integer,Integer> function = x -> x * 2;

function.apply(2); // 
```





##### 高阶函数（higher-order function）

高阶函数的定义是，接收一个或多个函数变量作为参数，然后生成的新函数，即为高阶函数。具体有两种情况：

1. 函数可以作为参数被传递
2. 函数可以作为返回值输出

让我们再次使用函数 double 来说明这个概念：

```xml
double = fn(x) -> x * 2
Enum.map(1..10, double) 
```

这例子中，Enum.map 将一个枚举列表作为第一参数，之前定义的函数作为第二参数；然后将这个函数应用到枚举中的每一个元素，结果为：

```xml
[2,4,6,8,10,12,14,16,18,20] 
```

scala中的高阶函数

```xml
  def test(f:Int => String , num : Int) = f(num)
  
  def f(num:Int) : String = {
    10 + num + ""
  }

  def main(args: Array[String]): Unit = {
    println(test(f,10))
  }
```







java中的例子

```xml
Integer[] arr = new Integer[]{2,4,6,8,10,12,14,16,18,20};
Arrays.stream(arr)
                .map(function)
                .toArray();
```



java非常常见的写法

```xml
Arrays.sort(arr, (s1, s2)->s1.compareToIgnoreCase(s2));
```





##### 不可变状态（Immutable State）

在函数式编程语言中，状态是不可变的。这意味着一旦一个变量被绑定了一个值，它将不能再被重新定义。这在防止副作用与条件竞争上有明显的优势，使并发编程更简单。

另外，函数式编程中的“值不可变性”避免了对公共的可变状态进行同步访问控制的复杂问题，能够较好满足分布式并行编程的需求，适应大数据时代的到来。



和上面一样，让我们使用 Elixir 来说明一下这概念：

```xml
iex> tuple = {:ok, "hello"} 
{:ok, "hello"} 
iex> put_elem(tuple, 1, "world") 
{:ok, "world"} 
iex> tuple 
{:ok, "hello"} 
```

这个例子中，tuple 的值从来没有改变过，第三行 put_elem 是返回了一个完全新的 tuple， 而没有去修改原有的值。



Scala 中定义变量分为 var（可变变量）和 val（不可变变量）

Scala 中集合框架也分为可变集合和不可变集合。比如 List（列表） 和 Tuple（元组）本身就是不可变的，set 和 map 分为可变和不可变的，默认为不可变。

```xml
    //创建List
    val list = List("abc","xyz")


    //添加元素。list本身不变，返回一个新的list
    val list1 = list :+ 6 //加到后面 List(abc, xyz, 6)
    val list2 = 10 +: list //加到前面 List(10, abc, xyz)
```





##### 函数组合子（Functional Combinators）

组合子逻辑意图作为简单的元逻辑，它能澄清在逻辑符号中的量化变量的意义，并真正的消除对它们的需要。消除量化变量的另一种方式是[蒯因](https://zh.wikipedia.org/wiki/蒯因)的谓词函子。尽管多数组合子逻辑系统超出了一阶逻辑的表达能力，蒯因的谓词函子的表达能力等价于一阶逻辑





- map对列表中的每个元素应用一个函数，返回应用后的元素所组成的列表。
- filter移除任何对传入函数计算结果为false的元素。返回一个布尔值的函数通常被称为谓词函数[或判定函数]。
- zip将两个列表的内容聚合到一个对偶列表中。
- partition将使用给定的谓词函数分割列表。
- find返回集合中第一个匹配谓词函数的元素。
- foldLeft，0为初始值（记住numbers是List[Int]类型），m作为一个累加器。
- flatten将嵌套结构扁平化为一个层次的集合。
- flatMap是一种常用的组合子，结合映射[mapping]和扁平化[flattening]。 flatMap需要一个处理嵌套列表的函数，然后将结果串连起来。



scala

```xml
scala> numbers.map((i: Int) => i * 2)
res0: List[Int] = List(2, 4, 6, 8)

scala> numbers.filter((i: Int) => i % 2 == 0)
res0: List[Int] = List(2, 4)

scala> List(1, 2, 3).zip(List("a", "b", "c"))
res0: List[(Int, String)] = List((1,a), (2,b), (3,c))

scala> val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
scala> numbers.partition(_ % 2 == 0)
res0: (List[Int], List[Int]) = (List(2, 4, 6, 8, 10),List(1, 3, 5, 7, 9))

scala> numbers.find((i: Int) => i > 5)
res0: Option[Int] = Some(6)

scala> numbers.foldLeft(0)((m: Int, n: Int) => m + n)
res0: Int = 55
```





```xml
        Integer[] arr = new Integer[]{2,4,6,8,10,12,14,16,18,20};
        Arrays.stream(arr)
                .map(x -> x * 2)
                .toArray();
```



##### 柯里化函数(Currying)

在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。



```scala
scala> def mul(x:Int,y:Int):Int = x *y
mul: (x: Int, y: Int)Int

scala> mul(6,7)
res12: Int = 42


scala> def mul2(x:Int)(y:Int)=x*y
mul2: (x: Int)(y: Int)Int


scala> mul2(6)(7)
res14: Int = 42

// 实际上是先变成这样一个函数
scala> def mul2(x:Int)=(y:Int)=>x*y
mul2: (x: Int)Int => Int


scala> val result = mul2(6)
result: (y:Int)=>6*y


scala> val sum = result(7)
sum: 42
```







运用

```scala
def getLines(filename: String)(isFileReadable: (File) => Boolean)(closableStream: (Closeable) => Unit):List[String] = {
  val file = new File(filename)
  if (isFileReadable(file)) {
    val readerStream = new FileReader(file)
    val buffer = new BufferedReader(readerStream)
    try {
      var list: List[String] = List()
      var str = ""
      var isReadOver = false
      while (!isReadOver) {
        str = buffer.readLine()
        if (str == null) isReadOver = true
        else list = str :: list
      }
      list.reverse
    } finally {
      closableStream(buffer)
      closableStream(readerStream)
    }
  } else {
    List()
  }
}

def isReadable(file: File) = {
  if (null != file && file.exists() && file.canRead()) true
  else false
}
def closeStream(stream: Closeable) {
  if (null != stream) {
    try {
      stream.close
    } catch {
      case ex => Log.error(“[”+this.getClass.getName+”.closeStream]”,ex.getMessage)
    }
  }
}


def getLines(filename:String):List[String]={
  getLines(filename)(isReadable)(closeStream)
}
```



spark源码

```scala
def sql(sqlText: String): DataFrame = {
    Dataset.ofRows(self, sessionState.sqlParser.parsePlan(sqlText))
}
        
        
override def parsePlan(sqlText: String): LogicalPlan = parse(sqlText) { parser =>
    astBuilder.visitSingleStatement(parser.singleStatement()) match {
      case plan: LogicalPlan => plan
      case _ =>
        val position = Origin(None, None)
        throw new ParseException(Option(sqlText), "Unsupported SQL statement", position, position)
    }
  }        





protected def parse[T](command: String)(toResult: SqlBaseParser => T): T = {
    logInfo(s"Parsing command: $command")

    val lexer = new SqlBaseLexer(new ANTLRNoCaseStringStream(command))
    lexer.removeErrorListeners()
    lexer.addErrorListener(ParseErrorListener)

    val tokenStream = new CommonTokenStream(lexer)
    val parser = new SqlBaseParser(tokenStream)
    parser.addParseListener(PostProcessor)
    parser.removeErrorListeners()
    parser.addErrorListener(ParseErrorListener)

    try {
      try {
        // first, try parsing with potentially faster SLL mode
        parser.getInterpreter.setPredictionMode(PredictionMode.SLL)
        toResult(parser)
      ...
```

java中的柯里化

```java
Function<String,
Function<String,
Function<String, String>>> sum =
    a -> b -> c -> a + b + c; 

Function<String, Function<String, String>> hi =
    sum.apply("Hi ");
Function<String, String> ho = hi.apply("Ho ");
        System.out.println(ho.apply("Hup"));
```

#### 函数式编程下的并发编程

一般来说有两种策略用来在并发线程中进行通信：共享数据和消息传递。使用共享数据方式的并发编程面临的最大的一个问题就是数据条件竞争。处理各种锁的问题是让人十分头痛的一件事。



传统多数流行的语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors使用消息模型，每个Actor在同一时间处理最多一个消息，可以发送消息给其他Actor，保证了单独写原则。从而巧妙避免了多线程写争夺。和共享数据方式相比，消息传递机制最大的优点就是不会产生数据竞争状态。实现消息传递有两种常见的类型：基于channel（golang为典型代表）的消息传递和基于Actor（erlang为代表）的消息传递。



##### Actor简介

Actor模型(Actor model)首先是由Carl Hewitt在1973定义， 由Erlang OTP 推广，其 消息传递更加符合面向对象的原始意图。Actor属于并发组件模型，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。



Actor模型=数据+行为+消息。

erlang，在语言层面就提供了Actor模型的支持，RabbitMQ 就是基于erlang开发的。



##### 



##### 无锁

JAVA并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改(通过消息传递来进行状态修改)，所以使用Actors模型进行并发编程可以很好地避免这些问题。Actor内部是以单线程的模式来执行的，类似于redis，所以Actor完全可以实现分布式锁类似的应用。



##### 异步

每个Actor都有一个专用的MailBox来接收消息，这也是Actor实现异步的基础。当一个Actor实例向另外一个Actor发消息的时候，并非直接调用Actor的方法，而是把消息传递到对应的MailBox里，就好像邮递员，并不是把邮件直接送到收信人手里，而是放进每家的邮箱，这样邮递员就可以快速的进行下一项工作。所以在Actor系统里，Actor发送一条消息是非常快的。





![img](/hexo/images/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1646915681082-e71378c3-a1e2-44c5-88b9-98ce0d485827.png)



这样的设计主要优势就是解耦了Actor，数万个Actor并发的运行，每个actor都以自己的步调运行，且发送消息，接收消息都不会被阻塞。



##### 隔离

每个Actor的实例都维护这自己的状态，与其他Actor实例处于物理隔离状态，并非像 多线程+锁 模式那样基于共享数据。Actor通过消息的模式与其他Actor进行通信，与OO式的消息传递方式不同，Actor之间消息的传递是真正物理上的消息传递。



##### 天生分布式

每个Actor实例的位置透明，无论Actor地址是在本地还是在远程机器上对于代码来说都是一样的。每个Actor的实例非常小，最多几百字节，所以单机几十万的Actor的实例很轻松。如果你写过golang代码，就会发现其实Actor在重量级上很像Goroutine。由于位置透明性，所以Actor系统可以随意的横向扩展来应对并发，对于调用者来说，调用的Actor的位置就在本地，当然这也得益于Actor系统强大的路由系统。











```scala
case class SetRequest(key: String, value: String)


class AkkademyDb extends Actor {
  val map = new HashMap[String, String]
  val log = Logging(context.system, this)

  override def receive = {
    case SetRequest(key, value) => {
      log.info("received SetRequest - key: {} value: {}", key, value)
      map.put(key, value)
    }
    case o => log.info("received unknown message: {}", o);
  }
}



val actorRef = TestActorRef(new AkkademyDb)
actorRef ! SetRequest("key", "value")
```



### 思维的转变



总结下函数式常用思维方式：



1. **表达式化**
   就是去掉变量，去掉循环，通过表达式处理逻辑。
2. **数据与行为分离，无副作用**
   由于严格作用域，必须没有副作用。
3. **高阶思维**
   能用 map 解决的，就不要 for 循环
4. **组合思维**
   函数式和面向对象是相反的，面向对象是自顶向下的设计，函数式是自底向上的设计，也就是先定义基本操作，然后不断组合。比如 sql 定义了 select， from， where ... 这些组合子来满足查询需求。
